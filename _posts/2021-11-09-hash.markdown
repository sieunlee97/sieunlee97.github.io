---
title: Hash
categories:
- 자료구조
last_modified_at: 2021-11-09T14:00:00+09:00
toc: true
---

## 해시? 해시테이블?
### 해시테이블
해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인 또는 주소 삼아 데이터를 key와 함께 저장하는 자료구조이다. 단순하게 key-value로 이루어진 자료구조라고 생각하면 된다.

### Hash Function
자료구조를 배우는 이유는 원하는 값을 최대한 효율적으로 찾을 수 있게 하기 위해서 여러가지 저장구조를 배우는 것이다. 데이터를 최대한 빠르게 찾기 위해서는 저장하는 위치도 잘 생각해서 저장해야 한다.<br>
해시함수의 정의는 key를 **고정된 길이**의 hash로 변경해주는 역할을 한다. 이 과정을 hashing이라고 한다. <br>
**key를 해시함수라는 함수에 input으로 넣어서 output으로 나오는 것이 hash**라고 생각하면 되고, 이 hash가 저장위치가 된다고 생각하면 된다. 즉, **Hash Function은 key로 해시를 만들어내는 함수**이다.

<div>
원래 데이터의 값(key) -> Hash Function -> Hash Function의 결과 = Hash Code
-> Hash Code를 배열의 인덱스로 사용 -> 해당하는 index에 data(value) 넣기
</div>
{: .notice--info}

### Hash Table 구성
- **key** <br>
고유한 값, hash function의 input이 된다. <br>
key 값을 그대로 저장소의 색인으로 사용할 경우 key의 길이만큼의 정보를 저장하는 공간도 따로 마련해야하기 때문에(key의 길이가 제각각일 수 있다.) 고정된 길이의 해시로 변경한다.
- **hash function** <br>
key를 고정된 길이의 hash로 변경해주는 역할을 한다. <br>
서로 다른 key가 hashing 후 같은 hash값이 나오는 경우가 있다. 이를 해시충돌이라고 부른다. 해시 충돌 발생 확률이 적을수록 좋다.<br>
해시충돌이 균등하게 발생하도록 하는 것도 중요하다. 모든 키가 같은 해시값이 나오게 되면 데이터 저장 시 비효율성도 커지고 보안이 취약해져서 좋지 않다.
- **value** <br>
저장소(버킷, 슬롯)에 최종적으로 저장되는 값으로, hash와 매칭되어 저장되어진다. 
- **hash table** <br>
해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 주소 또는 색인 삼아 데이터(value)를 key와 함께 저장하는 자료구조이다. <br>
데이터가 저장되는 곳을 버킷, 슬롯이라고 한다.
<div>
해시는 색인 또는 인덱스, hash function은 key->hash로 만들어 주는 함수, 해시테이블은 hash를 주소로 삼아 데이터를 저장하는 자료구조이다.
</div>
{: .notice--info}

### Hash Table 장/단점
- **장점**<br>
Key-Value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 검색의 과정에서 모두 평균적으로 O(1)의 시간 복잡도를 갖고 있다.
- **단점**<br>
[해시 충돌](#해시-충돌)이 발생한다.(개방 주소법, 체이닝과 같은 기법으로 해결해야 한다.) <br>
순서/관계가 있는 배열에는 어울리지 않는다. <br>
공간효율성이 떨어진다. 데이터가 저장되기 전에 저장공간을 미리 만들어놔야 한다. 공간을 만들었지만 공간에 채워지지 않는 경우가 발생한다. <br>
hash function 의존도가 높다. 해시함수가 복잡하다면 hash를 만들어내는데 오래 걸릴 것이다. <br>

## 해시 충돌
A, B 두가지 key가 있다. A와 B를 hash function으로 해시값을 얻었는데 hash값이 2로 똑같이 나왔다. 이런 현상을 hash collision이라고 한다. <br>
해시 함수로 해시를 만드는 과정에서 서로 다른 key가 같은 해시로 변경되면 같은 공간에 2개의 value가 저장되므로, key-value가 1:1 매핑되어야 하는 해시 테이블의 특성에 위배된다. 해시 충돌은 필연적으로 나타날 수 밖에 없다.

### solution1. Chaining
체이닝은 저장소(bucket)에서 충돌이 일어나면 기존 값과 새로운 값을 연결리스트로 연결하는 방법이다.
- **장점** <br>
미리 충돌을 대비해서 공간을 많이 잡아놓을 필요가 없다. 충돌이 나면 그 때 공간을 만들어서 연결만 해주면 된다.
- **단점** <br>
같은 해시에 자료들이 많이 연결되면 검색 시 효율이 낮아진다.

### solution2. Addressing(개방주소법)
충돌이 일어나면 비어있는 해시에 데이터를 저장하는 방법이다. 개방주소법의 해시테이블은 hash와 value가 1:1 관계를 유지한다. <br>
비어있는 hash를 찾아가는 방법은 여러가지가 있다.
- **선형탐색** <br>
해시값에서 고정폭으로 건너 뛰면서 비어있는 해시가 나오면 저장하게 된다.
- **제곱탐색** <br>
고정폭이 아닌 1칸->4칸->9칸->16칸씩 건너 뛰면서 빈 칸을 찾는다. 해시값이 같은 해시들이 들어오면 공간을 많이 확보해놔야 한다.
- **이중해싱** <br>
해시 충돌 시 다른 해시함수를 한번 더 적용시킴

## 해시함수 매핑 개선
특정 값에 치우치지 않고 해시값을 고르게 만들어내는 해시함수가 좋은 해시함수라고 할 수 있다.
### division method
가장 기본적인 해시함수이다. 숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 변환한다. 간다하면서도 빠른 연산이 가능한 것이 장점이다. 해시의 중복을 방지하기 위해 테이블의 크기 m은 소수로 지정해서 사용하는 것이 좋다. 하지만 남는 공간이 발생해 메모리상으로 비효율적이다.
### multiplication method
숫자 키 k, A는 0<A<1 사이의 실수일 때 h(k)=(kA mod 1) * m으로 계산한다. 2진수 연산에 최적화된 컴퓨터구조를 고려한 해시함수이다.
### univeral hasing
여러 개의 해시함수를 만들고, 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법.<br>
서로 다른 해시함수가 서로 다른 해시값을 만들어내기 때문에 같은 공간에 매핑할 확률을 줄이는 것이 목적이다.

---

## Java에서 사용하는 Hash
HashTable이란 jdk 1.0부터 있던 java의 API이고, HashMap은 java2에서 처음 선보인 Java Collection Framework에 속한 API이다. <br>
HashTable 또한 Map 인터페이스를 구현하고 있기 때문에 HashMap과 HashTable이 제공하는 기능은 같다.

